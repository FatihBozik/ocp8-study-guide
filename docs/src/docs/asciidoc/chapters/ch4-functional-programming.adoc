[[chapter-4]]
== Functional Programming

=== Using Variables in Lambdas

Lambda expressions can access

- static variables,
- instance variables,
- final or effectively final method parameters and
- final or effectively final local variables.

[source,java]
----
interface Gorilla { String move();}
class GorillaFamily {
    String walk = "walk";
    void everyonePlay(boolean baby) {
        String approach = "amble";
        // approach = "run";
        play(() -> walk);
        play(() -> baby ? "hitch a ride" : "run");
        play(() -> approach);
    }
    void play(Gorilla g) {
        System.out.println(g.move());
    }
}
----

If we uncomment `// approach = "run"` line, there will be reassignment and when it tries to access non-effectively final variable.
The normal rules for access control still apply.
For example, a lambda can't access `private` variables in another class.

=== Working with Built-in Functional Interfaces

A functional interface has exactly one abstract method.
All of the functional interfaces in below table provided in the `java.util.function` package.

.Common Functional Interfaces (T: Generic type, U: Second parameter type, R: Return type)
[stripes=even]
|===
|Functional Interfaces |# Parameters |Return Type |Single Abstract Method

|Supplier<T>
|0
|T
|get

|Consumer<T>
|1 (T)
|void
|accept

|BiConsumer<T, U>
|2 (T, U)
|void
|accept

|Predicate<T>
|1 (T)
|boolean
|test

|BiPredicate<T, U>
|2 (T, U)
|boolean
|test

|Function<T, R>
|1 (T)
|R
|apply

|BiFunction<T, U, R>
|2 (T, U)
|R
|apply

|UnaryOperator<T>
|1 (T)
|T
|apply

|BinaryOperator<T>
|2 (T, T)
|T
|apply
|===

Many other functional interfaces are defined in the `java.util.function` package.
They are working with primitives.

{empty} +

NOTE: There's an interface called `Runnable`.
It is used for concurrency the majority of the time. `Runnable` doesn't take any parameters, return any data, or use generics.

{empty} +


==== Implementing _Supplier_

A `Supplier` is used when you want to generate or supply values without taking any input.

[source,java]
----
@FunctionalInterface
public interface Supplier<T> {
    public T get();
}
----

[source,java]
----
Supplier<LocalDate> s1 = LocalDate::now;
Supplier<LocalDate> s2 = () -> LocalDate.now();

LocalDate d1 = s1.get();
LocalDate d2 = s2.get();

System.out.println(d1); // 2020-03-29
System.out.println(d2); // 2020-03-29
----

The `LocalDate::now` method reference is used to create a `Supplier` to assign to an intermediate variable s1. A `Supplier` is often used to when constructing new objects.

[source,java]
----
Supplier<StringBuilder> s1 = StringBuilder::new;
Supplier<StringBuilder> s2 = () -> new StringBuilder();

System.out.println(s1.get());
System.out.println(s2.get());

Supplier<ArrayList<String>> s3 = ArrayList<String>::new; // ArrayList::new;
ArrayList<String> a1 = s3.get();
System.out.println(a1);
----

==== Implementing _Consumer_ and _BiConsumer_

You use a `Consumer` when you want to do something with parameter but not return anything. `BiConsumer` does the same thing except that it takes two parameters.

[source,java]
----
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);

    // omitting default method
}
----

[source,java]
----
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);

    // omitting default method
}
----

{empty} +

NOTE: You'll notice this pattern.
_Bi_ means two, it comes from Latin.

{empty} +


[source,java]
----
Consumer<String> c1 = System.out::println;
Consumer<String> c2 = x -> System.out.println(x);

c1.accept("Annie"); // prints Annie
c2.accept("Annie"); // prints Annie
----

Java uses the context of the lambda to determine which overloaded `println()` method it should call.

`BiConsumer` is called with two parameters.
They don't have to be the same type.
For example, we can put a key and a value in a map using this interface.

[source,java]
----
Map<String, Integer> map = new HashMap<>();
BiConsumer<String, Integer> bc1 = map::put;
BiConsumer<String, Integer> bc2 = (k, v) -> map.put(k, v);

bc1.accept("chicken", 7);
bc2.accept("chick", 1);

System.out.println(map); // prints {chicken=7, chick=1}
----

==== Implementing _Predicate_ and _BiPredicate_

`Predicate` is often used when filtering or matching.
Both are very common operations.
A `BiPredicate` is just like a `Predicate` except that it takes two parameters instead of one.

[source,java]
----
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);

    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);

    // omitting any default or static methods
}
----

[source,java]
----
Predicate<String> p1 = String::isEmpty;
Predicate<String> p2 = x -> x.isEmpty();

System.out.println(p1.test("")); // prints true
System.out.println(p2.test("")); // prints true


BiPredicate<String, String> bp1 = String::startsWith;
BiPredicate<String, String> bp2 = (string, prefix) -> string.startsWith(prefix);

System.out.println(bp1.test("chicken", "chick")); // prints true
System.out.println(bp2.test("chicken", "chick")); // prints true
----

`startsWith` is an instance method.
This means that the first parameter in the lambda is used as the instance on which to call the method.
The second parameter is passed to the `startsWith` method itself.

.Default Methods on Functional Interfaces
****
By definition, all functional interfaces have a single abstract method.
This doesn't mean that they have only one method, though.
Several of the common functional interfaces provide number of helpful `default` methods.

Suppose that we have these two predicates.

[source,java]
----
Predicate<String> egg = s -> s.contains("egg");
Predicate<String> brown = s -> s.contains("brown");
----

Now we want a predicate for brown eggs and another for all other colors of eggs.
We could write this by hand:

[source,java]
----
Predicate<String> brownEggs = s -> s.contains("egg") && s.contains("brown");
Predicate<String> otherEggs = s -> s.contains("egg") && !s.contains("brown");
----

A better way to deal with this situation is to use two of the `default` methods on `Predicate`.

[source,java]
----
Predicate<String> brownEggs = egg.and(brown);
Predicate<String> otherEggs = egg.and(brown.negate());
----
****

==== Implementing _Function_ and _BiFunction_

A `Function` is responsible for turning one parameter into a value of a potentially different type and returning it.
Similarly, a `BiFunction` is responsible for turning two parameters ito a value and returning it.

[source,java]
----
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);

    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);

    // omitting any default or static methods
}
----

For example, this function converts a `String` to the length of the String:

[source,java]
----
Function<String, Integer> f1 = String::length;
Function<String, Integer> f2 = s -> s.length();

System.out.println(f1.apply("cluck")); // prints 5
System.out.println(f2.apply("cluck")); // prints 5
----

The following combines two `String` objects and produces another `String`.

[source,java]
----
BiFunction<String, String, String> bf1 = String::concat;
BiFunction<String, String, String> bf2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(bf1.apply("baby ", "chick")); // prints baby chick
System.out.println(bf2.apply("baby ", "chick")); // prints baby chick
----

.Creating Your Own Functional Interfaces
****
Java provides a built-in interface for functions with one or two parameters.
What if you need more?
You could create a functional interface such as this:

[source,java]
----
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
----

[source,java]
----
@FunctionalInterface
public interface QuadFunction<T, U, V, W, R> {
    R apply(T t, U u, V v, W w);
}
----
****

==== Implementing _UnaryOperator_ and _BinaryOperator_

`UnaryOperator` and `BinaryOperator` are a special case of a function.
They require all type parameters to be the same type.
An `UnaryOperator` transforms its value into one of the same type.
For example, incrementing by one is unary operator.
In fact, `UnaryOperator` extends `Function`.
A `BinaryOperator` merges two values into one of the same type.
Adding two numbers is a binary operation.
Similarly, `BinaryOperator` extends `BiFunction`.

[source,java]
----
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
    // omitting any default or static methods
}
----

If you look at the Javadoc, you'll notice that `apply` methods are actually declared on the `Function/BiFunction` superclass.
The generic declarations on the subclass are what force the type to be the same.

[source,java]
----
UnaryOperator<String> u1 = String::toUpperCase;
UnaryOperator<String> u2 = x -> x.toUpperCase();

System.out.println(u1.apply("chirp")); // prints CHIRP
System.out.println(u2.apply("chirp")); // prints CHIRP


BinaryOperator<String> b1 = String::concat;
BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // prints baby chick
System.out.println(b2.apply("baby ", "chick")); // prints baby chick
----

=== Returning an _Optional_

An `Optional` is created using a factory.
You can either request an empty `Optional` or pass a value for the `Optional` to wrap.
Think of an `Optional` as a box that might have something in it or might instead be empty.

[source,java]
----
public class OptionalDemo {
    public static void main(String[] args) {
        System.out.println(average(90, 100)); // prints Optional[95.0]
        System.out.println(average());        // prints Optional.empty
    }

    public static Optional<Double> average(int... scores) {
        if (scores.length == 0) return Optional.empty();
        int sum = 0;
        for (int score : scores) sum += score;
        return Optional.of((double) sum / scores.length);
    }
}
----

You can see that one `Optional` contains a value and the other is empty.
Normally, we want to check if a value is there and/or get it out of the box.
Here's one way to do that:

[source,java]
----
Optional<Double> opt = average(90, 100);
if(opt.isPresent()) {
    System.out.println(opt.get()); // 95.0
}
----

What if we didn't do the check and the `Optional` was empty?

[source,java]
----
Optional<Double> opt = average();
System.out.println(opt.get()); // throws java.util.NoSuchElementException: No value present
----

.`Optional` instance methods
[stripes=even,cols="3a, 5a, 5a",options="header"]
|===
|Method |When `Optional` is Empty |When `Optional` Contains a Value

|`get()`
|Throws an exception
|Returns value

|`ifPresent(Consumer c)`
|Does nothing
|Calls `Consumer c` with value

|`isPresent()`
|Returns `false`
|Returns `true`

|orElse(T other)
|Returns `other` parameter
|Returns value

|orElseGet(Supplier s)
|Returns result of calling `Supplier`
|Returns value

|orElseThrow(Supplier s)
|Throws exception created by calling `Supplier`
|Returns value
|===

You already seen `get()` and `isPresent()`.
The other methods allow you to write code that uses an `Optional` in one line without having to use the ternary operator.

[source,java]
----
Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println); // 95.0
----

Using `ifPresent` better expresses our intent.
We want something done if a value is present.
The other methods allow you to specify what to do if a value isn't present.

[source,java]
----
Optional<Double> opt2 = average();
System.out.println(opt2.orElse(Double.NaN)); // NaN
System.out.println(opt2.orElseGet(() -> Math.random())); // 0.295228248010566
System.out.println(opt2.orElseThrow(() -> new IllegalStateException())); // throws java.lang.IllegalStateException
----

=== Using Streams

A _stream_ in Java is a sequence of data.
A _stream pipeline_ is the operations that run on a stream to produce a result.
There are three parts to a stream pipeline:

- _Source_: Where the stream comes from.
- _Intermediate operations_: Transforms the stream into another one.
There can be as few or as many intermediate operations as you'd like.
Since streams use lazy evaluation, the intermediate operations do not run util the terminal operation run.
- _Terminal operation_: Actually produces a result.
Since streams can be used only once, the stream is no longer valid after a terminal operation completes.

.Intermediate vs. terminal operations
[stripes=even,cols="3, 1, 1"]
|===
|Scenario |For Intermediate Operations? |For Terminal Operations?

|Required part of a useful pipeline?
|No
|Yes

|Can exist multiple times in a pipeline?
|Yes
|No

|Return type is a stream type?
|Yes
|No

|Executed upon method call?
|No
|Yes

|Stream valid after call?
|Yes
|No
|===

==== Creating Stream Sources

In Java, the `Stream` interface is in the `java.util.stream` package.
There are a few ways to create finite stream:

[source,java]
----
Stream<String> empty = Stream.empty();          // count = 0
Stream<Integer> singleElement = Stream.of(1);   // count = 1;
Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3;
----

Since streams are new in Java 8, most code that's already written uses lists.
Java provides a convenient way to convert from list to a stream.

[source,java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> fromList = list.stream(); // <1>
Stream<String> fromListParallel = list.parallelStream(); // <2>
----
<1> Simple method call to create a stream from list
<2> Creates stream that is allowed to process elements in parallel.

Just keep in mind that it isn't worth working in parallel for small streams.
There is overhead cost in coordinating the work among all of the workers operating in parallel.
For small amounts of work, it is faster just to do it sequentially.

We can't create an infinite list, though, which makes streams more powerful:

[source,java]
----
Stream<Double> randoms = Stream.generate(Math::random);
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);
----

`Stream.generate(Math::random)` generates streams of random numbers.
If you call `randoms.forEach(System.out::println)`, the program will print random numbers until you kill it.

`iterate` takes a seed or starting value as the first parameter.
This is the first element that will be part of the stream.
The other parameter is lambda expression that get passed the previous value and generates the next value.

==== Using Common Terminal Operations

You can perform a terminal operation without any intermediate operations but not the other way around.
_Reductions_ are a special type of terminal operation where all of the contents of the stream are combined into a single primitive or `Object`.
For example, you might have an `int` or a `Collection`.

.Terminal stream operations
[stripes=even,cols="1a, 2, 1a, 1",width="70%"]
|===
|Method |What Happens for Infinite Streams |Return Value |Reduction

|`allMatch()`
/`anyMatch()`
/`noneMatch()`
|Sometimes terminates
|`boolean`
|No

|`collect()`
|Does not terminate
|Varies
|Yes

|`count()`
|Does not terminate
|`long`
|Yes

|`findAny()`
/`findFirst()`
|Terminates
|`Optional<T>`
|No

|`forEach`
|Does not terminate
|void
|No

|`min()`/`max()`
|Does not terminate
|`Optional<T>`
|Yes

|`reduce()`
|Does not terminate
|Varies
|Yes
|===

===== _count()_

The `count()` method determines the number of elements in a finite stream.
For an infinite stream, it hangs. `count()` is a reduction because it looks at each element in the stream and returns a single value.
The method signature is this: `long count()`

[source,java]
----
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // prints 3
----

===== _min()_ and _max()_

The `min()` and `max()` methods allow you to pass a custom comparator and find the smallest or largest value in a finite stream according to that sort order.
Like `count()`, `min()` and `max()` hang on an infinite stream.
Both methods are reductions.
The method signatures are as follows:

[source,java]
----
Optional<T> min(<? super T> comparator);
Optional<T> max(<? super T> comparator);
----

[source,java]
----
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length() - s2.length());
min.ifPresent(System.out::println); // ape
----

Notice that the code returns an `Optional` rather than the value.
This allows the method to specify that no minimum or maximum was found.

[source,java]
----
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
----

Since the stream is empty, the comparator is never called and no value is present in the `Optional`.

===== _findAny()_ and _findFirst()_

The `findAny()` and `findFirst()` methods return an element of the stream unless the stream is empty.
If the stream is empty, they return an empty `Optional`.
`findAny()` is useful when you are working with a parallel stream.
It gives Java the flexibility to return to you the first element it comes by rather than the one that needs to be first in the stream based on intermediate operations.

These methods are terminal operations but not reductions.
The reason is that they sometimes return without processing all of the elements.
This means that they return a value based on the stream but do not reduce the entire stream into one value.

The method signatures are these:

[source,java]
----
Optional<T> findAny();
Optional<T> findFirst();
----

[source,java]
----
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.findAny().ifPresent(System.out::println); // monkey

Stream<String> infinite = Stream.generate(() -> "chimp");
infinite.findAny().ifPresent(System.out::println); // chimp
----

Finding any one match is more useful than it sounds.
Sometimes we just want to sample the results and get a representative element, but we don't need to waste the processing generating them all.

===== _allMatch()_, _anyMatch()_ and _noneMatch()_

The _allMatch()_, _anyMatch()_ and _noneMatch()_ methods search a stream and return information about how the stream pertains to the predicate.
These may or may not terminate for infinite streams.
It depends on the data.
Like find methods, they are not reductions because they do not necessarily look at all of the elements.
The method signatures are as follows:

[source,java]
----
boolean anyMatch(Predicate<? super T> predicate)
boolean allMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
----

This example checks whether animal names begin with letters.

[source,java]
----
List<String> list = Arrays.asList("monkey", "2", "chimp");
Predicate<String> beginsWithLetterPredicate = s -> Character.isLetter(s.charAt(0));
System.out.println(list.stream().anyMatch(beginsWithLetterPredicate)); // true
System.out.println(list.stream().allMatch(beginsWithLetterPredicate)); // false
System.out.println(list.stream().noneMatch(beginsWithLetterPredicate)); // false

Stream<String> infinite = Stream.generate(() -> "chimp");
System.out.println(infinite.anyMatch(beginsWithLetterPredicate)); // true
----

On the infinite list, one match is found, so the call terminates.
If we called `noneMatch()` or `allMatch()`, they would run until we killed the program.

NOTE: Remember that `allMatch()`, `anyMatch()` and `noneMatch()` return a `boolean`.
By contrast, the find methods return an `Optional` because they return an element of the stream.

===== _forEach()_

A looping construct is available.
As expected, calling `forEach()` on an infinite stream does not terminate.
Since there is no return value, it is not a reduction.

Before you use it, consider if another approach would be better.
For example, a loop with an if statement should be a filter instead.

[source,java]
----
void forEach(Consumer<? super T> action);
----

Notice that this is the only terminal operation with a return type of `void`.
If you wanted something to happen, you have to make it happen in loop.
Here's one way to print the elements in the stream.

[source,java]
----
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.forEach(System.out::print); // monkeygorillabonobo
----

NOTE: Remember that you can call `forEach` directly on a `Collection` or on a `Stream`.
Don't get confused on the exam when you see both approaches.

Notice that you can't use a traditional for loop on a stream.

[source,java]
----
Stream<Integer> s = Stream.of(1);
for (Integer i : s) { } // DOES NOT COMPILE
----

Streams cannot use a traditional for loop to run because they don't implement the `Iterable` interface.

===== _reduce()_

The `reduce()` method combines a stream into a single object.
As you can tell from the name, it is a reduction.

[source,java]
----
T reduce(T identity, BinaryOperator<T> accumulator)

Optional<T> reduce(BinaryOperator<T> accumulator)

<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
----

The most common way of doing a reduction is to start with an initial value and keep merging it with the next value.

[source,java]
.Without Functional Programming
----
String[] array = new String[]{"w", "o", "l", "f"};
String result = "";
for (String s : array) result = result + s;
System.out.println(result); // wolf
----

The initial value of an empty `String` is the identity.
The accumulator combines the current result with the current `String`.
With lambdas, we can do the same thing with a stream and reduction:

[source,java]
.Functional Way
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf
----

Notice how we still have the empty `String` as identity.
We also still concatenate the `Strings` to get the next value.
We can even rewrite this with a method reference:

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf
----

Write a reduction to multiply all of the `Integer` objects in a stream?

[source,java]
----
Stream<Integer> streamOfInteger = Stream.of(3, 5, 6);
System.out.println(streamOfInteger.reduce(1, (a, b) -> a * b)); // 90
----

In many cases, the identity isn't really necessary, so Java lets us omit it.
When you don't specify an identity, an `Optional` is returned because there might not be any data.
There are three choices for what in the `Optional`:

- If the stream is empty, an empty `Optional` is returned.
- If the stream has one element, it is returned.
- If the stream has multiple elements, the accumulator is applied to combine them.

[source,java]
----
BinaryOperator<Integer> multiplication = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
empty.reduce(multiplication).ifPresent(System.out::println); // No output

Stream<Integer> oneElement = Stream.of(3);
oneElement.reduce(multiplication).ifPresent(System.out::println); // 3

Stream<Integer> threeElements = Stream.of(3, 5, 6);
threeElements.reduce(multiplication).ifPresent(System.out::println); // 90
----

The third method signatures is used when we are processing collections in parallel.
It allows Java to create immediate reductions and then combine them at the end.

[source,java]
----
BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(threeElements.reduce(1, op, op)); // 90
----

===== _collect()_

The `collect()` method is a special type of reduction called a _mutable reduction_.
It is more efficient than a regular reduction because we use the same mutable object while accumulating.
Common mutable objects include `StringBuilder` and `ArrayList`.
This is a really useful method, because it lets us get data out of streams and into another form.
The method signatures are as follows:

[source,java]
----
<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)

<R, A> collect(Collector<? super T, A, R> collector)
----

Our wolf example from `reduce` can be converted to use `collect()`:

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
System.out.println(word); // wolf
----

The first parameter is a `Supplier` that creates the object that will store the results as we collect data.
Remember that a `Supplier` doesn't take any parameters and returns a value.
In this case, it constructs a new `StringBuilder`.

The second parameter is a `BiConsumer`, which takes two parameters and doesn't return anything.
It is responsible for adding one more element to the data collection.
In this example, it appends the next `String` to the `StringBuilder`.

The final parameter is another `BiConsumer`.
It is responsible for taking two data collections and merging them.
This is useful when we are processing in parallel.
Two smaller collections formed and then merged into one.
This would work with `StringBuilder` only we didn't care about the order of the letters.
In this case, the accumulator and combiner have similar logic.

Now let's look at an example where the logic is different in the accumulator and combiner:

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add, TreeSet::addAll);
System.out.println(set); // [f, l, o, w]
----

The collector has three parts as before.
The supplier creates an empty `TreeSet`.
The accumulator adds a single `String` from the `Stream` to the `TreeSet`.
The combiner adds all of the elements of one `TreeSet` to another in case the operations were done in parallel and need to be merged.

In practice, there are many common collectors that come up over and over.
Rather than making developers keep reimplementing the same ones, Java provides an interface with common collectors.

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
----

If we didn't need the set to be sorted, we could make the code even shorter:

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
----

You might get different output for this last one since `toSet()` makes no guarantees as to which implementation of `Set` you'll get.
It is likely to be a `HashSet`, but you should'nt expect or rely on that.

==== Using Common Intermediate Operations

