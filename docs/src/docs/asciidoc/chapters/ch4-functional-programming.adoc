[[chapter-4]]
== Functional Programming

=== Using Variables in Lambdas

Lambda expressions can access

- static variables,
- instance variables,
- final or effectively final method parameters and
- final or effectively final local variables.

[source,java]
----
interface Gorilla { String move();}
class GorillaFamily {
    String walk = "walk";
    void everyonePlay(boolean baby) {
        String approach = "amble";
        // approach = "run";
        play(() -> walk);
        play(() -> baby ? "hitch a ride" : "run");
        play(() -> approach);
    }
    void play(Gorilla g) {
        System.out.println(g.move());
    }
}
----

If we uncomment `// approach = "run"` line, there will be reassignment and when it tries to access non-effectively final variable.
The normal rules for access control still apply.
For example, a lambda can't access `private` variables in another class.

=== Working with Built-in Functional Interfaces

A functional interface has exactly one abstract method.
All of the functional interfaces in below table provided in the `java.util.function` package.

.Common Functional Interfaces (T: Generic type, U: Second parameter type, R: Return type)
[stripes=even]
|===
|Functional Interfaces |# Parameters |Return Type |Single Abstract Method

|Supplier<T>
|0
|T
|get

|Consumer<T>
|1 (T)
|void
|accept

|BiConsumer<T, U>
|2 (T, U)
|void
|accept

|Predicate<T>
|1 (T)
|boolean
|test

|BiPredicate<T, U>
|2 (T, U)
|boolean
|test

|Function<T, R>
|1 (T)
|R
|apply

|BiFunction<T, U, R>
|2 (T, U)
|R
|apply

|UnaryOperator<T>
|1 (T)
|T
|apply

|BinaryOperator<T>
|2 (T, T)
|T
|apply
|===

Many other functional interfaces are defined in the `java.util.function` package.
They are working with primitives.

{empty} +

NOTE: There's an interface called `Runnable`.
It is used for concurrency the majority of the time. `Runnable` doesn't take any parameters, return any data, or use generics.

{empty} +


==== Implementing _Supplier_

A `Supplier` is used when you want to generate or supply values without taking any input.

[source,java]
----
@FunctionalInterface
public interface Supplier<T> {
    public T get();
}
----

[source,java]
----
Supplier<LocalDate> s1 = LocalDate::now;
Supplier<LocalDate> s2 = () -> LocalDate.now();

LocalDate d1 = s1.get();
LocalDate d2 = s2.get();

System.out.println(d1); // 2020-03-29
System.out.println(d2); // 2020-03-29
----

The `LocalDate::now` method reference is used to create a `Supplier` to assign to an intermediate variable s1. A `Supplier` is often used to when constructing new objects.

[source,java]
----
Supplier<StringBuilder> s1 = StringBuilder::new;
Supplier<StringBuilder> s2 = () -> new StringBuilder();

System.out.println(s1.get());
System.out.println(s2.get());

Supplier<ArrayList<String>> s3 = ArrayList<String>::new; // ArrayList::new;
ArrayList<String> a1 = s3.get();
System.out.println(a1);
----

==== Implementing _Consumer_ and _BiConsumer_

You use a `Consumer` when you want to do something with parameter but not return anything. `BiConsumer` does the same thing except that it takes two parameters.

[source,java]
----
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);

    // omitting default method
}
----

[source,java]
----
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);

    // omitting default method
}
----

{empty} +

NOTE: You'll notice this pattern.
_Bi_ means two, it comes from Latin.

{empty} +


[source,java]
----
Consumer<String> c1 = System.out::println;
Consumer<String> c2 = x -> System.out.println(x);

c1.accept("Annie"); // prints Annie
c2.accept("Annie"); // prints Annie
----

Java uses the context of the lambda to determine which overloaded `println()` method it should call.

`BiConsumer` is called with two parameters.
They don't have to be the same type.
For example, we can put a key and a value in a map using this interface.

[source,java]
----
Map<String, Integer> map = new HashMap<>();
BiConsumer<String, Integer> bc1 = map::put;
BiConsumer<String, Integer> bc2 = (k, v) -> map.put(k, v);

bc1.accept("chicken", 7);
bc2.accept("chick", 1);

System.out.println(map); // prints {chicken=7, chick=1}
----

==== Implementing _Predicate_ and _BiPredicate_

`Predicate` is often used when filtering or matching.
Both are very common operations.
A `BiPredicate` is just like a `Predicate` except that it takes two parameters instead of one.

[source,java]
----
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);

    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);

    // omitting any default or static methods
}
----

[source,java]
----
Predicate<String> p1 = String::isEmpty;
Predicate<String> p2 = x -> x.isEmpty();

System.out.println(p1.test("")); // prints true
System.out.println(p2.test("")); // prints true


BiPredicate<String, String> bp1 = String::startsWith;
BiPredicate<String, String> bp2 = (string, prefix) -> string.startsWith(prefix);

System.out.println(bp1.test("chicken", "chick")); // prints true
System.out.println(bp2.test("chicken", "chick")); // prints true
----

`startsWith` is an instance method.
This means that the first parameter in the lambda is used as the instance on which to call the method.
The second parameter is passed to the `startsWith` method itself.

.Default Methods on Functional Interfaces
****
By definition, all functional interfaces have a single abstract method.
This doesn't mean that they have only one method, though.
Several of the common functional interfaces provide number of helpful `default` methods.

Suppose that we have these two predicates.

[source,java]
----
Predicate<String> egg = s -> s.contains("egg");
Predicate<String> brown = s -> s.contains("brown");
----

Now we want a predicate for brown eggs and another for all other colors of eggs.
We could write this by hand:

[source,java]
----
Predicate<String> brownEggs = s -> s.contains("egg") && s.contains("brown");
Predicate<String> otherEggs = s -> s.contains("egg") && !s.contains("brown");
----

A better way to deal with this situation is to use two of the `default` methods on `Predicate`.

[source,java]
----
Predicate<String> brownEggs = egg.and(brown);
Predicate<String> otherEggs = egg.and(brown.negate());
----
****

==== Implementing _Function_ and _BiFunction_

A `Function` is responsible for turning one parameter into a value of a potentially different type and returning it.
Similarly, a `BiFunction` is responsible for turning two parameters ito a value and returning it.

[source,java]
----
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);

    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);

    // omitting any default or static methods
}
----

For example, this function converts a `String` to the length of the String:

[source,java]
----
Function<String, Integer> f1 = String::length;
Function<String, Integer> f2 = s -> s.length();

System.out.println(f1.apply("cluck")); // prints 5
System.out.println(f2.apply("cluck")); // prints 5
----

The following combines two `String` objects and produces another `String`.

[source,java]
----
BiFunction<String, String, String> bf1 = String::concat;
BiFunction<String, String, String> bf2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(bf1.apply("baby ", "chick")); // prints baby chick
System.out.println(bf2.apply("baby ", "chick")); // prints baby chick
----

.Creating Your Own Functional Interfaces
****
Java provides a built-in interface for functions with one or two parameters.
What if you need more?
You could create a functional interface such as this:

[source,java]
----
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
----

[source,java]
----
@FunctionalInterface
public interface QuadFunction<T, U, V, W, R> {
    R apply(T t, U u, V v, W w);
}
----
****

==== Implementing _UnaryOperator_ and _BinaryOperator_

`UnaryOperator` and `BinaryOperator` are a special case of a function.
They require all type parameters to be the same type.
An `UnaryOperator` transforms its value into one of the same type.
For example, incrementing by one is unary operator.
In fact, `UnaryOperator` extends `Function`.
A `BinaryOperator` merges two values into one of the same type.
Adding two numbers is a binary operation.
Similarly, `BinaryOperator` extends `BiFunction`.

[source,java]
----
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
    // omitting any default or static methods
}
----

[source,java]
----
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
    // omitting any default or static methods
}
----

If you look at the Javadoc, you'll notice that `apply` methods are actually declared on the `Function/BiFunction` superclass.
The generic declarations on the subclass are what force the type to be the same.

[source,java]
----
UnaryOperator<String> u1 = String::toUpperCase;
UnaryOperator<String> u2 = x -> x.toUpperCase();

System.out.println(u1.apply("chirp")); // prints CHIRP
System.out.println(u2.apply("chirp")); // prints CHIRP


BinaryOperator<String> b1 = String::concat;
BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // prints baby chick
System.out.println(b2.apply("baby ", "chick")); // prints baby chick
----

=== Returning an _Optional_

An `Optional` is created using a factory.
You can either request an empty `Optional` or pass a value for the `Optional` to wrap.
Think of an `Optional` as a box that might have something in it or might instead be empty.

[source,java]
----
public class OptionalDemo {
    public static void main(String[] args) {
        System.out.println(average(90, 100)); // prints Optional[95.0]
        System.out.println(average());        // prints Optional.empty
    }

    public static Optional<Double> average(int... scores) {
        if (scores.length == 0) return Optional.empty();
        int sum = 0;
        for (int score : scores) sum += score;
        return Optional.of((double) sum / scores.length);
    }
}
----

You can see that one `Optional` contains a value and the other is empty.
Normally, we want to check if a value is there and/or get it out of the box.
Here's one way to do that:

[source,java]
----
Optional<Double> opt = average(90, 100);
if(opt.isPresent()) {
    System.out.println(opt.get()); // 95.0
}
----

What if we didn't do the check and the `Optional` was empty?

[source,java]
----
Optional<Double> opt = average();
System.out.println(opt.get()); // throws java.util.NoSuchElementException: No value present
----

.`Optional` instance methods
[stripes=even,cols="3a, 5a, 5a",options="header"]
|===
|Method |When `Optional` is Empty |When `Optional` Contains a Value

|`get()`
|Throws an exception
|Returns value

|`ifPresent(Consumer c)`
|Does nothing
|Calls `Consumer c` with value

|`ifPresent()`
|Returns `false`
|Returns `true`

|orElse(T other)
|Returns `other` parameter
|Returns value

|orElseGet(Supplier s)
|Returns result of calling `Supplier`
|Returns value

|orElseThrow(Supplier s)
|Throws exception created by calling `Supplier`
|Returns value
|===

You already seen `get()` and `isPresent()`.
The other methods allow you to write code that uses an `Optional` in one line without having to use the ternary operator.

[source,java]
----
Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println); // 95.0
----

Using `ifPresent` better expresses our intent.
We want something done if a value is present.
The other methods allow you to specify what to do if a value isn't present.

[source,java]
----
Optional<Double> opt2 = average();
System.out.println(opt2.orElse(Double.NaN)); // NaN
System.out.println(opt2.orElseGet(() -> Math.random())); // 0.295228248010566
System.out.println(opt2.orElseThrow(() -> new IllegalStateException())); // throws java.lang.IllegalStateException
----

=== Using Streams

A _stream_ in Java is a sequence of data.
A _stream pipeline_ is the operations that run on a stream to produce a result.
There are three parts to a stream pipeline:

- _Source_: Where the stream comes from.
- _Intermediate operations_: Transforms the stream into another one.
There can be as few or as many intermediate operations as yo'd like.
Since streams use lazy evaluation, the intermediate operations do not run util the terminal operation run.
- _Terminal operation_: Actually produces a result.
Since streams can be used only once, the stream is no longer valid after a terminal operation completes.

.Intermediate vs. terminal operations
[stripes=even,cols="3, 1, 1"]
|===
|Scenario |For Intermediate Operations? |For Terminal Operations?

|Required part of a useful pipeline?
|No
|Yes

|Can exist multiple times in a pipeline?
|Yes
|No

|Return type is a stream type?
|Yes
|No

|Executed upon method call?
|No
|Yes

|Stream valid after call?
|Yes
|No
|===

==== Creating Stream Sources

In Java, the `Stream` interface is in the `java.util.stream` package.
There are a few ways to create finite stream:

[source,java]
----
Stream<String> empty = Stream.empty();          // count = 0
Stream<Integer> singleElement = Stream.of(1);   // count = 1;
Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3;
----

Since streams are new in Java 8, most code that's already written uses lists.
Java provides a convenient way to convert from list to a stream.

[source,java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> fromList = list.stream(); // <1>
Stream<String> fromListParallel = list.parallelStream(); // <2>
----
<1> Simple method call to create a stream from list
<2> Creates stream that is allowed to process elements in parallel.

Just keep in mind that it isn't worth working in parallel for small streams.
There is overhead cost in coordinating the work among all of the workers operating in parallel.
For small amounts of work, it is faster just to do it sequentially.

We can't create an infinite list, though, which makes streams more powerful:

[source,java]
----
Stream<Double> randoms = Stream.generate(Math::random);
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);
----

`Stream.generate(Math::random)` generates streams of random numbers.
If you call `randoms.forEach(System.out::println)`, the program will print random numbers until you kill it.

`iterate` takes a seed or starting value as the first parameter.
This is the first element that will be part of the stream.
The other parameter is lambda expression that get passed the previous value and generates the next value.

==== Using Common Terminal Operations

You can perform a terminal operation without ant intermediate operations but not the other way around.
_Reductions_ are a special type of terminal operation where all of the contents of the stream are combined into a single primitive or `Object`.
For example, you might have an `int` or a `Collection`.

.Terminal stream operations
[stripes=even,cols="1a, 2, 1a, 1",width="70%"]
|===
|Method |What Happens for Infinite Streams |Return Value |Reduction

|`allMatch()`
/`anyMatch()`
/`noneMatch()`
|Sometimes terminates
|`boolean`
|No

|`collect()`
|Does not terminate
|Varies
|Yes

|`count()`
|Does not terminate
|`long`
|Yes

|`findAny()`
/`findFirst()`
|Terminates
|`Optional<T>`
|No

|`forEach`
|Does not terminate
|void
|No

|`min()`/`max()`
|Does not terminate
|`Optional<T>`
|Yes

|`reduce()`
|Does not terminate
|Varies
|Yes
|===

===== _count()_

The `count()` method determines the number of elements in a finite stream.
For an infinite stream, it hangs. `count()` is a reduction because it looks at each element in the stream and returns a single value.
The method signature is this: `long count()`

[source,java]
----
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // prints 3
----

===== _min()_ and _max()_

The `min()` and `max()` methods allow you to pass a custom comparator and find the smallest or largest value in a finite stream according to that sort order.
Like `count()`, `min()` and `max()` hang on an infinite stream.
Both methods are reductions.
The method signatures are as follows:

[source,java]
----
Optional<T> min(<? super T> comparator);
Optional<T> max(<? super T> comparator);
----

[source,java]
----
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length() - s2.length());
min.ifPresent(System.out::println); // ape
----

Notice that the code returns an `Optional` rather than the value.
This allows the method to specify that no minimum or maximum was found.

[source,java]
----
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
----

Since the stream is empty, the comparator is never called and no valÄ±e is present in the `Optional`.

===== _findAny()_ and _findFirst()_
